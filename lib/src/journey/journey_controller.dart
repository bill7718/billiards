import 'package:billiards/beta/error_page.dart';
import 'package:flutter/material.dart';

///
/// Grouping abstract class for classes that control journeys
///
abstract class JourneyController {
  void start(BuildContext context);
}

///
/// Handles page events
///
/// Typically this object is constructor with a generic that is a class that holds the output from the page. This is passed into a page. The page responds to an Event (is a button click) by calling the
/// handler method.
///
/// By convention a page will try to handle events itself. But if the page needs any interaction with the external environment
/// then this is handler by the [JourneyController] class.
///
/// For example if a user enters an email address when they register the page will validate the format of the email address
/// but the [handler] function provided by the [JourneyController] would check to see if this email had already been used.
///
/// This allows the page to operate independently of the external environment which makes it easier to test
///
/// Typical code might look like this
///
/// a. The JourneyController displays the page
/// ```
///     Navigator.push(context, MaterialPageRoute(builder: (context)=>
///         LoginPage(
///             handler: PageEventHandler<LoginOutputState>(handleLogin), inputState: LoginInputState(),)) );
/// ```
///
/// b. The page calls the handler in response to a button click
/// ```
///   TextButton(
///                         child: const Text('Next'),
///                         onPressed: () {
///                           final state = formKey.currentState as FormState;
///                           if (state.validate()) {
///                             final nav = Navigator.of(context);
///                             handler.handleEvent(
///                                 nav,
///                                 LoginOutputState(
///                                     event: LoginEvent.next,
///                                     email: email,
///                                     password: password));
///                           }
///                         },
///                       )
/// ```
/// c. The handler handles the event and returns the next page
/// ```
///   Future<Widget> handleLogin(LoginOutputState pageOutputState) {
///     var c = Completer<Widget>();
///     switch (pageOutputState.event) {
///       case LoginEvent.back :
///         c.complete(const WelcomePage());
///         break;
///
///       case LoginEvent.next :
///        state.email = pageOutputState.email;   // save the email address to the journey state
///        ..... do some checking on the email address and if all is well go to the initial landing page
///        c.complete(const LandingPage());
///         break;
///     }
///     return c.future;
///   }
/// ```
class PageEventHandler<T> {

  /// Handles events generated by the page
  final Function handler;

  PageEventHandler(this.handler);

  /// Generic event handling. The journey controller processes the event and determines which is the next page
  /// This method handles the Navigation to the next page.
  void handleEvent(NavigatorState nav, T outputState) async {
    var widget = await handler(outputState);
    nav.push( MaterialPageRoute(builder: (_) => widget));
  }
  
  void handleException(NavigatorState nav, dynamic ex, { StackTrace? st }) {
    nav.push( MaterialPageRoute(builder: (_) => BilliardsErrorPage(error: ex,)));
  }
}

/// A list of events that are used by many pages.
enum DefaultEvent {
  next, back, home
}